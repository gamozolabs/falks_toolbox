<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Falk's Tap Drill Calculator</title>
    <style>
        :root {
            --bg: #1a1a2e;
            --bg-light: #16213e;
            --accent: #0f3460;
            --highlight: #e94560;
            --text: #eee;
            --text-dim: #aaa;
            --success: #4ade80;
            --warning: #fbbf24;
            --danger: #ef4444;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.5;
            padding: 1rem;
        }

        h1 {
            text-align: center;
            margin-bottom: 0.5rem;
            color: var(--highlight);
        }

        .subtitle {
            text-align: center;
            color: var(--text-dim);
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .standalone-note {
            text-align: center;
            color: var(--success);
            font-size: 0.75rem;
            margin-bottom: 1.5rem;
            opacity: 0.8;
        }

        /* Unified control panel - options left, results right */
        .control-panel {
            background: var(--bg-light);
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            max-width: 1000px;
            margin-left: auto;
            margin-right: auto;
            display: flex;
            gap: 1.5rem;
            align-items: flex-start;
        }

        .control-options {
            flex: 0 0 280px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .control-results {
            flex: 1 1 300px;
            min-width: 250px;
        }

        .option-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .option-label {
            font-size: 0.85rem;
            color: var(--text-dim);
            width: 75px;
            flex-shrink: 0;
        }

        .option-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--highlight);
            font-family: monospace;
            min-width: 45px;
        }

        .option-row input[type="range"] {
            -webkit-appearance: none;
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: var(--accent);
            outline: none;
        }

        .option-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--highlight);
            cursor: pointer;
            border: 2px solid var(--text);
        }

        .option-row input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--highlight);
            cursor: pointer;
            border: 2px solid var(--text);
        }

        .option-row input[type="number"] {
            padding: 0.35rem 0.5rem;
            border: 1px solid var(--accent);
            border-radius: 4px;
            background: var(--bg);
            color: var(--text);
            font-size: 0.9rem;
            width: 75px;
        }

        .option-row input[type="number"]:focus {
            outline: none;
            border-color: var(--highlight);
        }

        .option-row .input-unit {
            color: var(--text-dim);
            font-size: 0.8rem;
            width: 28px;
        }

        .option-row input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: var(--highlight);
        }

        .radio-group {
            display: flex;
            gap: 1rem;
        }

        .radio-group label {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            cursor: pointer;
            color: var(--text);
            font-size: 0.85rem;
        }

        .radio-group input[type="radio"] {
            cursor: pointer;
            margin: 0;
        }

        .toggle-info {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            color: var(--text-dim);
            font-size: 0.7rem;
            cursor: help;
        }

        .toggle-info:hover {
            background: var(--highlight);
            color: var(--text);
        }

        #custom-result {
            padding: 0.75rem;
            background: var(--bg);
            border-radius: 4px;
            font-family: monospace;
        }

        #custom-result .result-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 1.6rem;
            padding: 0.15rem 0;
            border-bottom: 1px solid var(--accent);
            font-size: 0.85rem;
        }

        #custom-result .result-row:last-child {
            border-bottom: none;
        }

        #custom-result .result-label {
            color: var(--text-dim);
        }

        #custom-result .result-row strong {
            color: var(--text);
        }

        /* Thread % label with tooltip */
        .pct-label {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            cursor: help;
        }

        /* Print-only summary (hidden on screen) */
        .print-summary {
            display: none;
        }

        /* Material preset buttons */
        .preset-btns {
            display: flex;
            gap: 0.4rem;
        }

        .preset-btn {
            padding: 0.25rem 0.6rem;
            border: 1px solid var(--accent);
            background: transparent;
            color: var(--text-dim);
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.15s;
        }

        .preset-btn:hover {
            background: var(--accent);
            color: var(--text);
        }

        .preset-btn.active {
            background: var(--highlight);
            border-color: var(--highlight);
            color: var(--text);
        }

        /* Tap type recommendation indicators */
        .tap-type-warn {
            position: relative;
        }
        .tap-type-warn::after {
            content: '⚠';
            position: absolute;
            top: -8px;
            right: -4px;
            font-size: 0.7rem;
        }
        .radio-group label.recommended {
            color: var(--success);
        }
        .radio-group label.not-recommended {
            color: var(--danger);
        }
        .radio-group label.not-recommended input {
            accent-color: var(--danger);
        }

        @media (max-width: 700px) {
            .control-panel {
                flex-direction: column;
            }
            .control-options {
                width: 100%;
                min-width: unset;
            }
        }

        .tables-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 1.5rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        .table-section {
            background: var(--bg-light);
            border-radius: 8px;
            overflow: hidden;
        }

        .table-header {
            background: var(--accent);
            padding: 0.75rem 1rem;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .table-header .badge {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            background: var(--bg);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        th {
            background: var(--bg);
            padding: 0.5rem;
            text-align: left;
            font-weight: 600;
            color: var(--text-dim);
            position: sticky;
            top: 0;
        }

        /* Fixed column widths to prevent layout shift when headers change */
        .col-mm, .col-in {
            width: 6.5rem;
            min-width: 6.5rem;
            white-space: nowrap;
        }

        td {
            padding: 0.5rem;
            border-bottom: 1px solid var(--accent);
        }

        tr:hover {
            background: rgba(233, 69, 96, 0.1);
        }

        tbody tr {
            cursor: pointer;
        }

        tbody tr.selected {
            background: rgba(233, 69, 96, 0.25);
            outline: 1px solid var(--highlight);
        }

        tbody tr.selected:hover {
            background: rgba(233, 69, 96, 0.3);
        }

        .drill-metric {
            font-weight: bold;
            cursor: help;
            color: var(--text);
        }

        .drill-inch {
            color: var(--text);
            cursor: help;
        }

        .drill-frac {
            cursor: help;
        }

        .drill-letter, .drill-number {
            font-weight: 500;
            cursor: help;
        }

        .no-match {
            color: var(--text-dim);
            font-style: italic;
        }

        .table-wrap {
            padding: 0;
        }

        .legend-section {
            max-width: 800px;
            margin: 1.5rem auto;
            padding: 1rem;
            background: var(--bg-light);
            border-radius: 8px;
        }

        .legend-section strong {
            display: block;
            margin-bottom: 0.75rem;
            color: var(--text);
        }

        .color-gradient {
            max-width: 400px;
        }

        .gradient-bar {
            height: 12px;
            border-radius: 6px;
            background: linear-gradient(to right,
                rgb(74,222,128) 0%,
                rgb(170,170,170) 33%,
                rgb(185,28,28) 100%);
        }

        .gradient-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            margin-top: 0.25rem;
            color: var(--text-dim);
        }


        .thread-size {
            font-weight: bold;
            white-space: nowrap;
        }

        .formula-info {
            max-width: 800px;
            margin: 1.5rem auto;
            padding: 1rem;
            background: var(--bg-light);
            border-radius: 8px;
            font-size: 0.85rem;
            color: var(--text-dim);
        }

        .formula-info code {
            background: var(--bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: monospace;
            color: var(--text);
        }

        @media (max-width: 900px) {
            .tables-container {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 600px) {
            body {
                padding: 0.5rem;
            }

            h1 {
                font-size: 1.4rem;
            }

            .subtitle {
                font-size: 0.8rem;
            }

            .standalone-note {
                font-size: 0.7rem;
            }

            .control-panel {
                padding: 1rem;
            }

            .option-value {
                font-size: 1rem;
            }

            .table-section {
                border-radius: 4px;
            }

            .table-wrap {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            table {
                font-size: 0.7rem;
                min-width: 380px;
            }

            td, th {
                padding: 0.3rem 0.25rem;
            }

            th {
                font-size: 0.65rem;
            }

            .formula-info,
            .legend-section {
                padding: 0.75rem;
                font-size: 0.8rem;
            }

            .radio-group {
                gap: 0.75rem;
            }

            .radio-group label {
                font-size: 0.8rem;
            }

            .option-label {
                width: 60px;
                font-size: 0.8rem;
            }

            .option-row input[type="number"] {
                width: 65px;
                font-size: 0.8rem;
            }

            #custom-result {
                font-size: 0.8rem;
            }

            #custom-result .result-row {
                min-height: 1.5rem;
                font-size: 0.8rem;
            }

            .gradient-bar {
                height: 10px;
            }

            .gradient-labels {
                font-size: 0.65rem;
            }

            .toggle-info {
                width: 14px;
                height: 14px;
                font-size: 0.65rem;
            }
        }

        @media (max-width: 400px) {
            .radio-group {
                flex-direction: column;
                gap: 0.5rem;
                align-items: flex-start;
            }

            table {
                font-size: 0.65rem;
                min-width: 340px;
            }
        }

        /* Print stylesheet */
        @media print {
            * {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }

            body {
                background: white;
                color: black;
                padding: 0;
                font-size: 10pt;
            }

            h1 {
                color: black;
                font-size: 16pt;
                margin-bottom: 0.25rem;
            }

            .subtitle {
                color: #444;
                margin-bottom: 0.25rem;
            }

            .standalone-note {
                display: none;
            }

            .control-panel {
                display: none;
            }

            /* Print-only summary shown via JS */
            .print-summary {
                display: block !important;
                border: 1px solid #ccc;
                padding: 0.5rem 0.75rem;
                margin-bottom: 1rem;
                font-size: 11pt;
            }

            .print-summary strong {
                font-size: 12pt;
            }

            .tables-container {
                display: block;
                max-width: 100%;
            }

            .table-section {
                background: none;
                page-break-inside: avoid;
                margin-bottom: 1rem;
                border: 1px solid #ccc;
            }

            .table-header {
                background: #eee;
                color: black;
                padding: 0.4rem 0.5rem;
                font-size: 11pt;
            }

            .table-header .badge {
                background: #ddd;
                color: #444;
                font-size: 8pt;
            }

            table {
                font-size: 9pt;
                border-collapse: collapse;
                width: 100%;
            }

            th {
                background: #f5f5f5;
                color: black;
                font-size: 8pt;
                padding: 0.3rem;
                border: 1px solid #ccc;
            }

            td {
                padding: 0.25rem 0.3rem;
                border: 1px solid #ccc;
            }

            tr:hover {
                background: none;
            }

            .drill-metric,
            .drill-inch,
            .drill-frac,
            .drill-letter,
            .drill-number {
                font-weight: normal;
                color: black !important;
            }

            .no-match {
                color: #666 !important;
            }

            .legend-section {
                display: none;
            }

            .formula-info {
                background: #f9f9f9;
                border: 1px solid #ddd;
                padding: 0.5rem;
                font-size: 8pt;
                page-break-inside: avoid;
                color: black;
            }

            .formula-info code {
                background: #eee;
                color: black;
            }

            .formula-info strong {
                color: black;
            }

        }
    </style>
</head>
<body>
    <h1>Falk's Tap Drill Calculator</h1>
    <p class="subtitle">Interactive thread percentage calculator with drill size lookup</p>
    <p class="standalone-note">This is a standalone HTML file with zero dependencies. Save this page (Ctrl+S) to use offline — no internet required. Part of <a href="https://github.com/gamozolabs/falks_toolbox" style="color: var(--success);">Falk's Toolbox</a>.</p>

    <div class="control-panel">
        <div class="control-options">
            <!-- Tap type -->
            <div class="option-row">
                <span class="option-label">Tap Type:</span>
                <div class="radio-group">
                    <label><input type="radio" name="tap-type" value="cut" checked> Cut</label>
                    <label><input type="radio" name="tap-type" value="roll"> Roll/Form</label>
                </div>
                <span class="toggle-info" title="Cut taps remove material — works on all materials.&#10;&#10;Roll/form taps displace material, requiring larger holes (near pitch diameter). 65% thread is standard.&#10;&#10;⚠ Roll taps require DUCTILE materials only!&#10;DO NOT use on: Cast iron, hardened steel (>35 HRC), plastics, or other brittle materials — they will crack.&#10;&#10;Best for: Aluminum, brass, copper, mild steel, stainless steel.">?</span>
            </div>

            <!-- Thread type -->
            <div class="option-row">
                <span class="option-label">Thread:</span>
                <div class="radio-group">
                    <label><input type="radio" name="custom-type" value="metric" checked> Metric</label>
                    <label><input type="radio" name="custom-type" value="inch"> Inch</label>
                </div>
            </div>

            <!-- Major diameter -->
            <div class="option-row">
                <span class="option-label">Major Ø:</span>
                <input type="number" id="custom-major" step="0.01" placeholder="20" value="20">
                <span class="input-unit" id="major-unit">mm</span>
            </div>

            <!-- Pitch -->
            <div class="option-row">
                <span class="option-label">Pitch:</span>
                <input type="number" id="custom-pitch" step="0.01" placeholder="1.5" value="1.5">
                <span class="input-unit" id="pitch-unit">mm</span>
            </div>

            <!-- Thread % slider -->
            <div class="option-row">
                <span class="option-label pct-label" id="pct-label" title="">Thread %:</span>
                <span class="option-value" id="pct-value">65%</span>
                <input type="range" id="pct-slider" min="40" max="85" value="65" step="1">
            </div>

            <!-- Material presets (unified - works for both tap types) -->
            <div class="option-row" id="material-presets">
                <span class="option-label"></span>
                <div class="preset-btns" id="material-btns">
                    <!-- Buttons generated by JS with material data -->
                </div>
            </div>

            <!-- Oversize toggle -->
            <div class="option-row">
                <span class="option-label">Oversize:</span>
                <label style="display: flex; align-items: center; gap: 0.4rem; cursor: pointer;">
                    <input type="checkbox" id="oversize-toggle">
                    <span style="font-size: 0.85rem; color: var(--text);">Compensate</span>
                </label>
                <span class="toggle-info" title="Drills cut oversize holes. When enabled, recommends a smaller drill to achieve the target hole size. Data from Machinery's Handbook p.897.">?</span>
            </div>

            <!-- Formula toggle -->
            <div class="option-row">
                <span class="option-label">Formula:</span>
                <div class="radio-group">
                    <label><input type="radio" name="formula-type" value="american" checked> 1.299</label>
                    <label><input type="radio" name="formula-type" value="unified"> 1.083</label>
                </div>
                <span class="toggle-info" title="1.299 = American National (0.75H, pre-1949) — used by most tables for consistency.&#10;1.083 = Unified/ISO (0.625H, current) — technically correct for modern threads.&#10;&#10;ASME B1.1-2003 eliminated 'percent thread' references due to this confusion.">?</span>
            </div>
        </div>

        <div class="control-results">
            <div id="custom-result"></div>
        </div>
    </div>

    <div class="print-summary" id="print-summary"></div>

    <div class="tables-container">
        <div class="table-section">
            <div class="table-header">
                UNC (Coarse)
                <span class="badge">Unified National Coarse</span>
            </div>
            <div class="table-wrap">
                <table id="unc-table">
                    <thead>
                        <tr>
                            <th>Thread</th>
                            <th class="col-mm" title="Recommended drill size in mm">Drill (mm)</th>
                            <th class="col-in" title="Recommended drill size in inches">Drill (in)</th>
                            <th title="Nearest fractional drill size">Frac</th>
                            <th title="Nearest letter or number drill">Letter/#</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div class="table-section">
            <div class="table-header">
                UNF (Fine)
                <span class="badge">Unified National Fine</span>
            </div>
            <div class="table-wrap">
                <table id="unf-table">
                    <thead>
                        <tr>
                            <th>Thread</th>
                            <th class="col-mm" title="Recommended drill size in mm">Drill (mm)</th>
                            <th class="col-in" title="Recommended drill size in inches">Drill (in)</th>
                            <th title="Nearest fractional drill size">Frac</th>
                            <th title="Nearest letter or number drill">Letter/#</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div class="table-section">
            <div class="table-header">
                Metric Coarse
                <span class="badge">ISO Standard</span>
            </div>
            <div class="table-wrap">
                <table id="metric-table">
                    <thead>
                        <tr>
                            <th>Thread</th>
                            <th class="col-mm" title="Recommended drill size in mm">Drill (mm)</th>
                            <th class="col-in" title="Recommended drill size in inches">Drill (in)</th>
                            <th title="Nearest fractional drill size">Frac</th>
                            <th title="Nearest letter or number drill">Letter/#</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <div class="legend-section">
        <strong>Color Legend</strong>
        <div class="color-gradient">
            <div class="gradient-bar"></div>
            <div class="gradient-labels">
                <span>0 mm</span>
                <span>0.05 mm</span>
                <span>0.15 mm+</span>
            </div>
            <div class="gradient-labels">
                <span style="color:rgb(74,222,128)">● Perfect</span>
                <span style="color:rgb(170,170,170)">● Acceptable</span>
                <span style="color:rgb(185,28,28)">● Poor</span>
            </div>
        </div>
        <p style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.75rem;">
            Color smoothly transitions based on deviation from ideal size. Letter/# shows "–" if deviation &gt;0.15 mm.
        </p>
    </div>

    <div class="formula-info">
        <strong>Understanding Hole Size vs Drill Size</strong>
        <ul style="margin: 0.5rem 0 0.75rem 1.5rem; padding: 0;">
            <li>Thread percentage is determined by the <em>hole diameter</em>, not the drill size.</li>
            <li>Since drills cut oversize, using a drill equal to the target hole produces a larger hole and lower thread %.</li>
        </ul>

        <strong>Column Definitions</strong>
        <ul style="margin: 0.5rem 0 0.75rem 1.5rem; padding: 0;">
            <li><strong>Hole Ø</strong> — Target hole diameter for your selected thread %. This is the
            minor diameter that determines actual thread engagement.</li>
            <li><strong>Drill</strong> — Recommended drill size. When oversize adjustment is enabled,
            this is smaller than the target hole to account for expected oversize.</li>
            <li><strong>Frac / Letter/#</strong> — Nearest standard drill sizes to the recommended drill.</li>
        </ul>

        <strong>Drill Oversize Data</strong> (Machinery's Handbook 29th Ed, p.897)
        <ul style="margin: 0.5rem 0 0.75rem 1.5rem; padding: 0;">
            <li>Based on US Cutting Tool Institute tests of 2800+ holes in steel and cast iron:</li>
        </ul>
        <table style="margin: 0 0 0.5rem 1.5rem; font-size: 0.8rem; border-collapse: collapse;">
            <tr style="background: var(--bg);">
                <th style="padding: 0.25rem 0.5rem; text-align: left;">Drill Ø</th>
                <th style="padding: 0.25rem 0.5rem;">Avg Max</th>
                <th style="padding: 0.25rem 0.5rem;">Mean</th>
                <th style="padding: 0.25rem 0.5rem;">Avg Min</th>
            </tr>
            <tr><td style="padding: 0.2rem 0.5rem;">1/16"</td><td style="padding: 0.2rem 0.5rem; text-align: center;">+0.002"</td><td style="padding: 0.2rem 0.5rem; text-align: center;">+0.0015"</td><td style="padding: 0.2rem 0.5rem; text-align: center;">+0.001"</td></tr>
            <tr><td style="padding: 0.2rem 0.5rem;">1/8"</td><td style="padding: 0.2rem 0.5rem; text-align: center;">+0.0045"</td><td style="padding: 0.2rem 0.5rem; text-align: center;">+0.003"</td><td style="padding: 0.2rem 0.5rem; text-align: center;">+0.001"</td></tr>
            <tr><td style="padding: 0.2rem 0.5rem;">1/4"</td><td style="padding: 0.2rem 0.5rem; text-align: center;">+0.0065"</td><td style="padding: 0.2rem 0.5rem; text-align: center;">+0.004"</td><td style="padding: 0.2rem 0.5rem; text-align: center;">+0.0025"</td></tr>
            <tr><td style="padding: 0.2rem 0.5rem;">1/2"</td><td style="padding: 0.2rem 0.5rem; text-align: center;">+0.008"</td><td style="padding: 0.2rem 0.5rem; text-align: center;">+0.005"</td><td style="padding: 0.2rem 0.5rem; text-align: center;">+0.003"</td></tr>
            <tr><td style="padding: 0.2rem 0.5rem;">3/4"</td><td style="padding: 0.2rem 0.5rem; text-align: center;">+0.008"</td><td style="padding: 0.2rem 0.5rem; text-align: center;">+0.005"</td><td style="padding: 0.2rem 0.5rem; text-align: center;">+0.003"</td></tr>
            <tr><td style="padding: 0.2rem 0.5rem;">1"</td><td style="padding: 0.2rem 0.5rem; text-align: center;">+0.009"</td><td style="padding: 0.2rem 0.5rem; text-align: center;">+0.007"</td><td style="padding: 0.2rem 0.5rem; text-align: center;">+0.004"</td></tr>
        </table>
        <ul style="margin: 0 0 0.75rem 1.5rem; padding: 0;">
            <li style="font-size: 0.75rem; color: var(--text-dim);">"When the drill point is accurately ground and the other machining conditions are correct,
            the resulting hole size is more likely to be between the mean and average minimum values."
            This calculator uses the <strong>mean</strong> value and interpolates for any drill size.</li>
        </ul>

        <strong>Cutting Tap Formulas</strong>
        <ul style="margin: 0.5rem 0 0.75rem 1.5rem; padding: 0;">
            <li>Unified/Inch: <code>Hole = Major − (K × %Thread / TPI)</code></li>
            <li>Metric: <code>Hole = Major − (K × Pitch × %Thread)</code></li>
            <li>Where K = 1.299 (American National) or 1.083 (Unified/ISO)</li>
        </ul>

        <strong>Roll/Form Tap Formulas</strong>
        <ul style="margin: 0.5rem 0 0.75rem 1.5rem; padding: 0;">
            <li>Inch: <code>Drill = Major − (0.0068 × %Thread) / TPI</code></li>
            <li>Metric: <code>Drill = Major − (%Thread × Pitch) / 147.06</code></li>
            <li>Roll taps displace material instead of cutting, requiring <strong>larger holes</strong>
            (approximately at pitch diameter). Industry standard is 65% thread.</li>
            <li>Example: 1/4-20 cut tap uses #7 drill; 1/4-20 roll tap uses #1 drill.</li>
            <li>Hole tolerance is critical — some recommend reaming to size (±0.001").</li>
        </ul>

        <strong>Why Two Constants? (1.299 vs 1.083)</strong>
        <ul style="margin: 0.5rem 0 0.75rem 1.5rem; padding: 0;">
            <li><strong>1.299</strong> (American National, pre-1949) — Based on 0.75H thread height.
            Most tables still use this for "consistency" even though the thread form is obsolete.</li>
            <li><strong>1.083</strong> (Unified/ISO, current) — Based on 0.625H thread height.
            Technically correct for modern threads (Machinery's Handbook p.2030).</li>
            <li>Both constants are derived from tan(60°) = √3.</li>
            <li>ASME B1.1-2003 eliminated "percent thread" references entirely, stating:
            <em>"Past changes in the thread form designation of the 'basic' thread height from 0.750H
            to 0.625H confused the calculation of percent of thread engagement."</em></li>
        </ul>

        <strong>Drill Matching</strong>
        <ul style="margin: 0.5rem 0 0.75rem 1.5rem; padding: 0;">
            <li>Letter (A-Z) and Number (#1-#80) drills shown when within ±0.08 mm (±3 thou).</li>
            <li>Fractional drills (1/64") always shown — see color legend above.</li>
            <li>Hover over any drill size for exact dimensions and deviations.</li>
        </ul>

        <strong>Thread % Guidelines</strong> (Machinery's Handbook 29th Ed, p.2020)
        <ul style="margin: 0.5rem 0 0.75rem 1.5rem; padding: 0;">
            <li>"Tests have shown that any increase in the percentage of full thread over <strong>60 per cent
            does not significantly increase the strength</strong> of the thread."</li>
            <li>"Often, a 55 to 60 per cent thread is satisfactory, although 75 per cent threads are
            commonly used to provide an extra measure of safety."</li>
            <li>"The tap drill should not be smaller than is necessary to give the required strength to
            the thread as even a very small decrease in the diameter of the drill will increase the
            torque required and the possibility of broken taps."</li>
            <li>(p.2018, Stainless): "Austenitic stainless steels are very difficult to tap because of
            their high resistance to cutting and their great tendency to work harden."</li>
        </ul>

        <strong>Industry Guidance</strong> (Guhring)
        <ul style="margin: 0.5rem 0 0.75rem 1.5rem; padding: 0;">
            <li>"Most tap drill charts call out only one tap drill size, and that will produce an approximate
            75 percent thread."</li>
            <li>"In general, <strong>tap tool life can be increased significantly by using a lower percent
            of thread</strong> and we suggest using values between 60% and 70% for most applications."</li>
            <li>"Thread strength is not directly proportional to percent of thread. For example a
            <strong>100% thread is only 5% stronger than a 75% thread but requires 3 times the torque</strong>
            to produce."</li>
        </ul>

        <strong>Material Reference</strong>
        <table style="margin: 0.5rem 0 0.75rem 1.5rem; font-size: 0.8rem; border-collapse: collapse; width: calc(100% - 1.5rem);">
            <tr style="background: var(--bg);">
                <th style="padding: 0.3rem 0.5rem; text-align: left;">Material</th>
                <th style="padding: 0.3rem 0.5rem; text-align: center;">Cut %</th>
                <th style="padding: 0.3rem 0.5rem; text-align: center;">Roll %</th>
                <th style="padding: 0.3rem 0.5rem; text-align: left;">Notes</th>
            </tr>
            <tr><td style="padding: 0.2rem 0.5rem;">Aluminum</td><td style="padding: 0.2rem 0.5rem; text-align: center;">75%</td><td style="padding: 0.2rem 0.5rem; text-align: center;">70%</td><td style="padding: 0.2rem 0.5rem;">Soft ductile — roll taps ideal for blind holes</td></tr>
            <tr><td style="padding: 0.2rem 0.5rem;">Brass/Copper</td><td style="padding: 0.2rem 0.5rem; text-align: center;">75%</td><td style="padding: 0.2rem 0.5rem; text-align: center;">70%</td><td style="padding: 0.2rem 0.5rem;">Ideal for roll/form tapping</td></tr>
            <tr><td style="padding: 0.2rem 0.5rem;">Steel (&lt;35 HRC)</td><td style="padding: 0.2rem 0.5rem; text-align: center;">65%</td><td style="padding: 0.2rem 0.5rem; text-align: center;">60%</td><td style="padding: 0.2rem 0.5rem;">Roll threads cold work and harden</td></tr>
            <tr><td style="padding: 0.2rem 0.5rem;">Stainless</td><td style="padding: 0.2rem 0.5rem; text-align: center;">60%</td><td style="padding: 0.2rem 0.5rem; text-align: center; color: var(--success);">60% ★</td><td style="padding: 0.2rem 0.5rem;">Roll preferred — no chips, stronger threads, longer life</td></tr>
            <tr><td style="padding: 0.2rem 0.5rem;">Cast Iron</td><td style="padding: 0.2rem 0.5rem; text-align: center;">65%</td><td style="padding: 0.2rem 0.5rem; text-align: center; color: var(--danger);">⚠ NO</td><td style="padding: 0.2rem 0.5rem;">Brittle — will crack if rolled</td></tr>
            <tr><td style="padding: 0.2rem 0.5rem;">Hardened (&gt;35 HRC)</td><td style="padding: 0.2rem 0.5rem; text-align: center;">50%</td><td style="padding: 0.2rem 0.5rem; text-align: center; color: var(--danger);">⚠ NO</td><td style="padding: 0.2rem 0.5rem;">Too hard to form — cut only</td></tr>
            <tr><td style="padding: 0.2rem 0.5rem;">Plastic</td><td style="padding: 0.2rem 0.5rem; text-align: center;">75%</td><td style="padding: 0.2rem 0.5rem; text-align: center; color: var(--danger);">⚠ NO</td><td style="padding: 0.2rem 0.5rem;">Sharp cut taps only</td></tr>
        </table>

        <strong>Cutting vs Roll Tap Selection</strong>
        <ul style="margin: 0.5rem 0 0 1.5rem; padding: 0;">
            <li><strong>Roll taps</strong> — Best for ductile materials (aluminum, brass, copper, mild steel,
            stainless). Chipless operation ideal for blind holes. 3-20× longer tool life. Stronger threads
            from cold-worked grain structure.</li>
            <li><strong>Cutting taps</strong> — Required for brittle materials (cast iron, hardened steel,
            plastics). Use straight flute for cast iron (chips fall out), spiral point for through holes.</li>
            <li style="color: var(--danger);"><strong>⚠ Never roll tap brittle materials</strong> — they will crack
            instead of forming threads.</li>
        </ul>
    </div>

    <script>
    // ==========================================================================
    // CONSTANTS AND DATA
    // ==========================================================================

    // ==========================================================================
    // CUTTING TAP CONSTANTS
    // ==========================================================================
    // Thread form constants derived from tan(60°) = √3
    // H (fundamental triangle height) = (√3/2) × P = 0.866025... × P
    //
    // American National (pre-1949): Basic height = 0.75H = (6/8)H
    //   Factor = 2 × 0.75 × (√3/2) = 0.75 × √3 = 1.299038...
    //
    // Unified/ISO (current): Basic height = 0.625H = (5/8)H
    //   Factor = 2 × 0.625 × (√3/2) = 0.625 × √3 = 1.082532...
    //
    // Most tables still use 1.299 for "consistency" even though the thread
    // form changed in 1949. ASME B1.1-2003 eliminated "percent thread"
    // references entirely due to this confusion.
    const SQRT3 = Math.sqrt(3);
    const TAP_FACTOR_AMERICAN = 0.75 * SQRT3;   // 1.299038105676658
    const TAP_FACTOR_UNIFIED = 0.625 * SQRT3;   // 1.0825317547305765

    // ==========================================================================
    // ROLL/FORM TAP CONSTANTS
    // ==========================================================================
    // Roll taps displace material instead of cutting, requiring larger holes
    // (approximately at pitch diameter).
    //
    // Industry standard formulas:
    //   Inch:   Drill = Major - (0.0068 × Thread%) / TPI
    //   Metric: Drill = Major - (Thread% × Pitch) / 147.06
    //
    // Note: Thread% in these formulas is 0-100, not 0-1
    // The constants are reciprocals: 1/147.06 ≈ 0.0068
    //
    // Derivation: 5/8 × cos(30°) = 0.625 × 0.866025 = 0.5413
    // For form taps: 0.5413 / 79.53 ≈ 0.0068
    const ROLL_TAP_FACTOR = 0.0068;             // For inch (Thread% as 0-100)
    const ROLL_TAP_DIVISOR = 147.06;            // For metric (1/0.0068)

    // ==========================================================================
    // MATERIAL DATA
    // ==========================================================================
    // Each material: { name, cutPct, rollPct, rollOk, tip }
    // rollOk: 'yes' = recommended, 'ok' = works, 'no' = will crack/fail
    const MATERIALS = [
        {
            name: 'Aluminum',
            cutPct: 75,
            rollPct: 70,
            rollOk: 'yes',
            tip: 'Soft ductile material. Roll taps work excellently — ideal for blind holes.'
        },
        {
            name: 'Brass',
            cutPct: 75,
            rollPct: 70,
            rollOk: 'yes',
            tip: 'Soft ductile material. Ideal for roll/form tapping.'
        },
        {
            name: 'Steel',
            cutPct: 65,
            rollPct: 60,
            rollOk: 'ok',
            tip: 'Mild steel (<35 HRC). Roll taps work — threads get cold worked and hard.'
        },
        {
            name: 'Stainless',
            cutPct: 60,
            rollPct: 60,
            rollOk: 'yes',
            tip: 'Roll taps preferred — no chip issues, stronger cold-worked threads, 3-20× longer life. Hole size is critical (consider reaming). Moly-Dee lubricant recommended.'
        },
        {
            name: 'Cast Iron',
            cutPct: 65,
            rollPct: null,
            rollOk: 'no',
            tip: 'Brittle — will CRACK if roll tapped. Use cutting tap with straight flute.'
        },
        {
            name: 'Hardened',
            cutPct: 50,
            rollPct: null,
            rollOk: 'no',
            tip: 'Hardened steel (>35 HRC). Too hard to form — cutting tap only.'
        },
        {
            name: 'Plastic',
            cutPct: 75,
            rollPct: null,
            rollOk: 'no',
            tip: 'Use sharp cutting taps only. Will not form properly.'
        },
    ];

    // Drill oversize data from Machinery's Handbook 29th Ed, p.897
    // "Oversize Diameters in Drilling" - US Cutting Tool Institute test data
    // Format: [drill_diameter_inch, avg_max_oversize, mean_oversize, avg_min_oversize]
    // Note: "when the drill point is accurately ground and the other machining
    // conditions are correct, the resulting hole size is more likely to be
    // between the mean and average minimum values"
    const DRILL_OVERSIZE_DATA = [
        [0.0625,  0.002,  0.0015, 0.001 ],  // 1/16"
        [0.125,   0.0045, 0.003,  0.001 ],  // 1/8"
        [0.25,    0.0065, 0.004,  0.0025],  // 1/4"
        [0.5,     0.008,  0.005,  0.003 ],  // 1/2"
        [0.75,    0.008,  0.005,  0.003 ],  // 3/4"
        [1.0,     0.009,  0.007,  0.004 ],  // 1"
    ];

    /**
     * Get expected drill oversize for a given drill diameter using linear interpolation.
     * Returns object with avgMax, mean, avgMin oversize values in inches.
     * For sizes outside the table range, extrapolates from nearest two points.
     *
     * @param {number} drillDiaInch - Drill diameter in inches
     * @returns {Object} - {avgMax, mean, avgMin} oversize in inches
     */
    function getDrillOversize(drillDiaInch) {
        const data = DRILL_OVERSIZE_DATA;

        // Handle edge cases: clamp to table range for extrapolation
        if (drillDiaInch <= data[0][0]) {
            // Below smallest - use smallest values (don't extrapolate to zero)
            return {
                avgMax: data[0][1],
                mean: data[0][2],
                avgMin: data[0][3]
            };
        }
        if (drillDiaInch >= data[data.length - 1][0]) {
            // Above largest - use largest values
            return {
                avgMax: data[data.length - 1][1],
                mean: data[data.length - 1][2],
                avgMin: data[data.length - 1][3]
            };
        }

        // Find bracketing points for interpolation
        let lower = data[0];
        let upper = data[1];
        for (let i = 0; i < data.length - 1; i++) {
            if (drillDiaInch >= data[i][0] && drillDiaInch <= data[i + 1][0]) {
                lower = data[i];
                upper = data[i + 1];
                break;
            }
        }

        // Linear interpolation
        const t = (drillDiaInch - lower[0]) / (upper[0] - lower[0]);
        return {
            avgMax: lower[1] + t * (upper[1] - lower[1]),
            mean: lower[2] + t * (upper[2] - lower[2]),
            avgMin: lower[3] + t * (upper[3] - lower[3])
        };
    }

    /**
     * Get the recommended drill size to achieve a target hole size,
     * accounting for expected drill oversize.
     * Uses the "mean" oversize as the expected value for a well-ground drill.
     *
     * @param {number} targetHoleInch - Desired hole diameter in inches
     * @returns {number} - Recommended drill diameter in inches
     */
    function getDrillForTargetHole(targetHoleInch) {
        // Iterative approach since oversize depends on drill size
        // Start with target as initial guess
        let drillSize = targetHoleInch;

        // A few iterations converge quickly
        for (let i = 0; i < 5; i++) {
            const oversize = getDrillOversize(drillSize);
            drillSize = targetHoleInch - oversize.mean;
        }

        return Math.max(0.001, drillSize); // Don't go negative
    }

    // UNC Threads: [name, major_dia_inch, tpi]
    const UNC_THREADS = [
        ["#0", 0.0600, 80],
        ["#1", 0.0730, 64],
        ["#2", 0.0860, 56],
        ["#3", 0.0990, 48],
        ["#4", 0.1120, 40],
        ["#5", 0.1250, 40],
        ["#6", 0.1380, 32],
        ["#8", 0.1640, 32],
        ["#10", 0.1900, 24],
        ["#12", 0.2160, 24],
        ["1/4", 0.2500, 20],
        ["5/16", 0.3125, 18],
        ["3/8", 0.3750, 16],
        ["7/16", 0.4375, 14],
        ["1/2", 0.5000, 13],
        ["9/16", 0.5625, 12],
        ["5/8", 0.6250, 11],
        ["3/4", 0.7500, 10],
        ["7/8", 0.8750, 9],
        ["1", 1.0000, 8],
    ];

    // UNF Threads: [name, major_dia_inch, tpi]
    const UNF_THREADS = [
        ["#0", 0.0600, 80],
        ["#1", 0.0730, 72],
        ["#2", 0.0860, 64],
        ["#3", 0.0990, 56],
        ["#4", 0.1120, 48],
        ["#5", 0.1250, 44],
        ["#6", 0.1380, 40],
        ["#8", 0.1640, 36],
        ["#10", 0.1900, 32],
        ["#12", 0.2160, 28],
        ["1/4", 0.2500, 28],
        ["5/16", 0.3125, 24],
        ["3/8", 0.3750, 24],
        ["7/16", 0.4375, 20],
        ["1/2", 0.5000, 20],
        ["9/16", 0.5625, 18],
        ["5/8", 0.6250, 18],
        ["3/4", 0.7500, 16],
        ["7/8", 0.8750, 14],
        ["1", 1.0000, 12],
    ];

    // Metric Coarse: [major_mm, pitch_mm]
    const METRIC_COARSE = [
        [1.6, 0.35],
        [2.0, 0.40],
        [2.5, 0.45],
        [3.0, 0.50],
        [3.5, 0.60],
        [4.0, 0.70],
        [5.0, 0.80],
        [6.0, 1.00],
        [8.0, 1.25],
        [10.0, 1.50],
        [12.0, 1.75],
        [14.0, 2.00],
        [16.0, 2.00],
        [18.0, 2.50],
        [20.0, 2.50],
        [24.0, 3.00],
        [30.0, 3.50],
    ];

    // Number drills: [number, size_inch]
    const NUMBER_DRILLS = [
        [80, 0.0135], [79, 0.0145], [78, 0.0160], [77, 0.0180], [76, 0.0200],
        [75, 0.0210], [74, 0.0225], [73, 0.0240], [72, 0.0250], [71, 0.0260],
        [70, 0.0280], [69, 0.0292], [68, 0.0310], [67, 0.0320], [66, 0.0330],
        [65, 0.0350], [64, 0.0360], [63, 0.0370], [62, 0.0380], [61, 0.0390],
        [60, 0.0400], [59, 0.0410], [58, 0.0420], [57, 0.0430], [56, 0.0465],
        [55, 0.0520], [54, 0.0550], [53, 0.0595], [52, 0.0635], [51, 0.0670],
        [50, 0.0700], [49, 0.0730], [48, 0.0760], [47, 0.0785], [46, 0.0810],
        [45, 0.0820], [44, 0.0860], [43, 0.0890], [42, 0.0935], [41, 0.0960],
        [40, 0.0980], [39, 0.0995], [38, 0.1015], [37, 0.1040], [36, 0.1065],
        [35, 0.1100], [34, 0.1110], [33, 0.1130], [32, 0.1160], [31, 0.1200],
        [30, 0.1285], [29, 0.1360], [28, 0.1405], [27, 0.1440], [26, 0.1470],
        [25, 0.1495], [24, 0.1520], [23, 0.1540], [22, 0.1570], [21, 0.1590],
        [20, 0.1610], [19, 0.1660], [18, 0.1695], [17, 0.1730], [16, 0.1770],
        [15, 0.1800], [14, 0.1820], [13, 0.1850], [12, 0.1890], [11, 0.1910],
        [10, 0.1935], [9, 0.1960], [8, 0.1990], [7, 0.2010], [6, 0.2040],
        [5, 0.2055], [4, 0.2090], [3, 0.2130], [2, 0.2210], [1, 0.2280],
    ];

    // Letter drills: [letter, size_inch]
    const LETTER_DRILLS = [
        ['A', 0.2340], ['B', 0.2380], ['C', 0.2420], ['D', 0.2460], ['E', 0.2500],
        ['F', 0.2570], ['G', 0.2610], ['H', 0.2660], ['I', 0.2720], ['J', 0.2770],
        ['K', 0.2810], ['L', 0.2900], ['M', 0.2950], ['N', 0.3020], ['O', 0.3160],
        ['P', 0.3230], ['Q', 0.3320], ['R', 0.3390], ['S', 0.3480], ['T', 0.3580],
        ['U', 0.3680], ['V', 0.3770], ['W', 0.3860], ['X', 0.3970], ['Y', 0.4040],
        ['Z', 0.4130],
    ];

    // Standard metric drill sizes (mm)
    const METRIC_DRILLS = [
        0.50, 0.55, 0.60, 0.65, 0.70, 0.75, 0.80, 0.85, 0.90, 0.95,
        1.00, 1.05, 1.10, 1.15, 1.20, 1.25, 1.30, 1.35, 1.40, 1.45,
        1.50, 1.55, 1.60, 1.65, 1.70, 1.75, 1.80, 1.85, 1.90, 1.95,
        2.00, 2.05, 2.10, 2.15, 2.20, 2.25, 2.30, 2.35, 2.40, 2.45,
        2.50, 2.55, 2.60, 2.65, 2.70, 2.75, 2.80, 2.85, 2.90, 2.95,
        3.00, 3.10, 3.20, 3.30, 3.40, 3.50, 3.60, 3.70, 3.80, 3.90,
        4.00, 4.10, 4.20, 4.30, 4.40, 4.50, 4.60, 4.70, 4.80, 4.90,
        5.00, 5.10, 5.20, 5.30, 5.40, 5.50, 5.60, 5.70, 5.80, 5.90,
        6.00, 6.10, 6.20, 6.30, 6.40, 6.50, 6.60, 6.70, 6.80, 6.90,
        7.00, 7.10, 7.20, 7.30, 7.40, 7.50, 7.60, 7.70, 7.80, 7.90,
        8.00, 8.20, 8.50, 8.80, 9.00, 9.50, 10.0, 10.5, 11.0, 11.5,
        12.0, 12.5, 13.0, 13.5, 14.0, 14.5, 15.0, 16.0, 17.0, 18.0,
        19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0, 27.0, 28.0,
    ];

    // Fractional drills: computed dynamically for any size (1/64" increments)

    // ==========================================================================
    // DRILL SIZE LOOKUP API
    // ==========================================================================

    /**
     * Find all matching drill sizes for a given diameter in mm
     * @param {number} targetMm - Target diameter in mm
     * @param {number} tolerance - Max acceptable difference (mm) for letter/number drills
     * @returns {Object} - {metric, decimalInch, letter, number, fractional, targetMm, targetInch}
     */
    function findDrillSizes(targetMm, tolerance = 0.08) {
        const targetInch = targetMm / 25.4;
        const result = {
            metric: null,
            decimalInch: null,
            letter: null,
            number: null,
            fractional: null,
            targetMm: targetMm,
            targetInch: targetInch
        };

        // Helper to format deviation string
        // 1 thou (mil) = 0.001" = 0.0254 mm
        // 1 tenth = 0.0001" = 0.00254 mm = 2.54 µm
        function formatDiff(diffMm) {
            const sign = diffMm >= 0 ? '+' : '';
            const absMm = Math.abs(diffMm);
            const diffThou = diffMm / 0.0254; // thousandths of inch
            return `${sign}${diffMm.toFixed(3)} mm (${sign}${diffThou.toFixed(1)} thou)`;
        }

        // Compute lerped color based on deviation
        // 0mm = green, 0.05mm = gray, 0.15mm+ = dark red
        function getQualityColor(absDiffMm) {
            // Green: rgb(74, 222, 128) - var(--success)
            // Gray: rgb(170, 170, 170) - var(--text-dim)
            // Dark Red: rgb(185, 28, 28) - #b91c1c
            const green = [74, 222, 128];
            const gray = [170, 170, 170];
            const red = [185, 28, 28];

            let r, g, b;
            if (absDiffMm <= 0.05) {
                // Lerp green to gray (0 to 0.05mm)
                const t = absDiffMm / 0.05;
                r = Math.round(green[0] + (gray[0] - green[0]) * t);
                g = Math.round(green[1] + (gray[1] - green[1]) * t);
                b = Math.round(green[2] + (gray[2] - green[2]) * t);
            } else if (absDiffMm <= 0.15) {
                // Lerp gray to red (0.05 to 0.15mm)
                const t = (absDiffMm - 0.05) / 0.10;
                r = Math.round(gray[0] + (red[0] - gray[0]) * t);
                g = Math.round(gray[1] + (red[1] - gray[1]) * t);
                b = Math.round(gray[2] + (red[2] - gray[2]) * t);
            } else {
                // Solid red beyond 0.15mm
                [r, g, b] = red;
            }
            return `rgb(${r},${g},${b})`;
        }

        // Find closest metric drill
        let closestMetric = null;
        let closestMetricDiff = Infinity;
        for (const size of METRIC_DRILLS) {
            const diff = Math.abs(size - targetMm);
            if (diff < closestMetricDiff) {
                closestMetricDiff = diff;
                closestMetric = size;
            }
        }
        if (closestMetricDiff <= tolerance) {
            const diffMm = closestMetric - targetMm;
            const absDiffMetric = Math.abs(diffMm);
            result.metric = {
                size: closestMetric,
                sizeMm: closestMetric,
                sizeInch: closestMetric / 25.4,
                diff: diffMm,
                absDiff: absDiffMetric,
                diffStr: formatDiff(diffMm),
                display: closestMetric.toFixed(2) + " mm",
                color: getQualityColor(absDiffMetric)
            };
        }

        // Find closest number drill
        let closestNum = null;
        let closestNumDiff = Infinity;
        for (const [num, size] of NUMBER_DRILLS) {
            const diff = Math.abs(size - targetInch);
            if (diff < closestNumDiff) {
                closestNumDiff = diff;
                closestNum = [num, size];
            }
        }
        if (closestNumDiff * 25.4 <= tolerance) {
            const diffMm = (closestNum[1] - targetInch) * 25.4;
            const absDiffNum = Math.abs(diffMm);
            result.number = {
                num: closestNum[0],
                size: closestNum[1],
                sizeMm: closestNum[1] * 25.4,
                sizeInch: closestNum[1],
                diff: diffMm,
                absDiff: absDiffNum,
                diffStr: formatDiff(diffMm),
                display: "#" + closestNum[0],
                color: getQualityColor(absDiffNum)
            };
        }

        // Find closest letter drill
        let closestLetter = null;
        let closestLetterDiff = Infinity;
        for (const [letter, size] of LETTER_DRILLS) {
            const diff = Math.abs(size - targetInch);
            if (diff < closestLetterDiff) {
                closestLetterDiff = diff;
                closestLetter = [letter, size];
            }
        }
        if (closestLetterDiff * 25.4 <= tolerance) {
            const diffMm = (closestLetter[1] - targetInch) * 25.4;
            const absDiffLetter = Math.abs(diffMm);
            result.letter = {
                letter: closestLetter[0],
                size: closestLetter[1],
                sizeMm: closestLetter[1] * 25.4,
                sizeInch: closestLetter[1],
                diff: diffMm,
                absDiff: absDiffLetter,
                diffStr: formatDiff(diffMm),
                display: closestLetter[0],
                color: getQualityColor(absDiffLetter)
            };
        }

        // Find closest fractional drill (1/64" increments, any size)
        // Round to nearest 64th
        const sixtyFourths = Math.round(targetInch * 64);
        const fracSizeInch = sixtyFourths / 64;
        const fracDiffMm = (fracSizeInch - targetInch) * 25.4;
        const absDiff = Math.abs(fracDiffMm);

        // Reduce fraction to lowest terms and format as X-Y/Z" for sizes > 1"
        const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
        const wholeInches = Math.floor(Math.abs(sixtyFourths) / 64);
        const remainingSixtyFourths = Math.abs(sixtyFourths) % 64;
        let fracDisplay;
        if (remainingSixtyFourths === 0) {
            // Exact whole inches (1", 2", etc.)
            fracDisplay = wholeInches + '"';
        } else {
            const g = gcd(remainingSixtyFourths, 64);
            const numer = remainingSixtyFourths / g;
            const denom = 64 / g;
            if (wholeInches > 0) {
                // Mixed number: 1-1/2", 2-3/4", etc.
                fracDisplay = wholeInches + '-' + numer + '/' + denom + '"';
            } else {
                // Pure fraction: 1/2", 3/4", etc.
                fracDisplay = numer + '/' + denom + '"';
            }
        }

        result.fractional = {
            num: sixtyFourths,
            size: fracSizeInch,
            sizeMm: fracSizeInch * 25.4,
            sizeInch: fracSizeInch,
            diff: fracDiffMm,
            absDiff: absDiff,
            diffStr: formatDiff(fracDiffMm),
            display: fracDisplay,
            color: getQualityColor(absDiff)
        };

        // Always provide decimal inch
        result.decimalInch = {
            size: targetInch,
            sizeMm: targetMm,
            display: targetInch.toFixed(4) + '"'
        };

        return result;
    }

    /**
     * Get the best "letter or number" drill for display
     */
    function getBestLetterOrNumber(drills) {
        // Prefer whichever is closer to target - NEVER return fractional
        if (drills.letter && drills.number) {
            if (Math.abs(drills.letter.diff) <= Math.abs(drills.number.diff)) {
                return drills.letter;
            }
            return drills.number;
        }
        return drills.letter || drills.number || null;
    }

    // ==========================================================================
    // TAP DRILL CALCULATIONS
    // ==========================================================================

    /**
     * Check if roll/form tap mode is selected
     */
    function isRollTap() {
        return document.querySelector('input[name="tap-type"]:checked').value === 'roll';
    }

    /**
     * Get the currently selected cutting tap factor
     */
    function getTapFactor() {
        const formula = document.querySelector('input[name="formula-type"]:checked').value;
        return formula === 'unified' ? TAP_FACTOR_UNIFIED : TAP_FACTOR_AMERICAN;
    }

    /**
     * Calculate tap drill size for imperial threads
     * @param {number} majorInch - Major diameter in inches
     * @param {number} tpi - Threads per inch
     * @param {number} threadPct - Thread percentage (0.0-1.0)
     * @returns {number} - Tap drill diameter in inches
     */
    function calcTapDrillInch(majorInch, tpi, threadPct) {
        if (isRollTap()) {
            // Roll tap: Drill = Major - (0.0068 × Thread%) / TPI
            // Note: formula expects Thread% as 0-100, we have 0-1
            return majorInch - (ROLL_TAP_FACTOR * (threadPct * 100) / tpi);
        }
        // Cutting tap
        return majorInch - (getTapFactor() * threadPct / tpi);
    }

    /**
     * Calculate tap drill size for metric threads
     * @param {number} majorMm - Major diameter in mm
     * @param {number} pitchMm - Pitch in mm
     * @param {number} threadPct - Thread percentage (0.0-1.0)
     * @returns {number} - Tap drill diameter in mm
     */
    function calcTapDrillMm(majorMm, pitchMm, threadPct) {
        if (isRollTap()) {
            // Roll tap: Drill = Major - (Thread% × Pitch) / 147.06
            // Note: formula expects Thread% as 0-100, we have 0-1
            return majorMm - ((threadPct * 100) * pitchMm / ROLL_TAP_DIVISOR);
        }
        // Cutting tap
        return majorMm - (getTapFactor() * pitchMm * threadPct);
    }

    // ==========================================================================
    // UI FUNCTIONS
    // ==========================================================================

    const slider = document.getElementById('pct-slider');
    const pctValue = document.getElementById('pct-value');
    const pctLabel = document.getElementById('pct-label');
    const oversizeToggle = document.getElementById('oversize-toggle');
    const printSummary = document.getElementById('print-summary');

    function isOversizeEnabled() {
        return oversizeToggle.checked;
    }

    /**
     * Update print-only summary with current settings
     */
    function updatePrintSummary(pct) {
        const useOversize = isOversizeEnabled();
        const columnType = useOversize ? 'Drill size (with oversize compensation)' : 'Hole diameter (no compensation)';
        const tapType = isRollTap() ? 'Roll/Form Tap' : 'Cut Tap';
        let formulaLabel = '';
        if (!isRollTap()) {
            const formula = document.querySelector('input[name="formula-type"]:checked').value;
            formulaLabel = ` &nbsp;|&nbsp; Formula: ${formula === 'unified' ? '1.083 (Unified)' : '1.299 (American National)'}`;
        }
        printSummary.innerHTML = `<strong>${tapType} — Thread: ${pct}%</strong>${formulaLabel} &nbsp;|&nbsp; Columns show: ${columnType}`;
    }

    /**
     * Update thread % display: color and tooltip based on value
     */
    function updatePctDisplay(pct) {
        let color, msg;
        if (pct >= 75) {
            color = 'var(--danger)';
            msg = 'High tap breakage risk. No strength benefit over 60% (MH p.2020).';
        } else if (pct > 65) {
            color = 'var(--warning)';
            msg = 'Above 65% — diminishing returns, higher torque required.';
        } else if (pct >= 50) {
            color = 'var(--success)';
            msg = 'Recommended range. Good balance of strength and tapping torque.';
        } else {
            color = 'var(--warning)';
            msg = 'Very light engagement. Verify adequate for load requirements.';
        }
        pctValue.textContent = pct + '%';
        pctValue.style.color = color;
        pctLabel.title = msg;
    }

    function formatDrillCell(drills, type) {
        // Helper to build consistent tooltip text
        function tooltip(drill, isExact = false) {
            if (!drill) return '';
            const mm = drill.sizeMm ? drill.sizeMm.toFixed(3) : (drill.size * 25.4).toFixed(3);
            const inch = drill.sizeInch ? drill.sizeInch.toFixed(4) : drill.size.toFixed(4);
            if (isExact) {
                return `Exact: ${mm} mm = ${inch}"`;
            }
            let tip = `Drill: ${mm} mm = ${inch}"`;
            if (drill.diffStr) {
                tip += `&#10;Deviation: ${drill.diffStr}`;
            }
            return tip;
        }

        if (type === 'metric') {
            // Exact calculated value
            const tip = tooltip({ sizeMm: drills.targetMm, sizeInch: drills.targetInch }, true);
            return `<span class="drill-metric" title="${tip}">${drills.targetMm.toFixed(2)} mm</span>`;
        }

        if (type === 'inch') {
            // Exact calculated decimal inch
            const tip = tooltip({ sizeMm: drills.targetMm, sizeInch: drills.targetInch }, true);
            return `<span class="drill-inch" title="${tip}">${drills.decimalInch.display}</span>`;
        }

        if (type === 'frac') {
            // Fractional drill with lerped color
            if (drills.fractional) {
                const tip = tooltip(drills.fractional);
                return `<span class="drill-frac" style="color:${drills.fractional.color}" title="${tip}">${drills.fractional.display}</span>`;
            }
            return `<span class="no-match">—</span>`;
        }

        if (type === 'letter') {
            const best = getBestLetterOrNumber(drills);
            if (best) {
                // Show "–" if the match is poor (absDiff > 0.15mm)
                if (best.absDiff > 0.15) {
                    const tip = `Closest: ${best.display}&#10;${tooltip(best).replace('Drill: ', '')}&#10;Poor match — not recommended`;
                    return `<span class="no-match" title="${tip}">–</span>`;
                }
                const baseClass = best.display.startsWith('#') ? 'drill-number' : 'drill-letter';
                const tip = tooltip(best);
                return `<span class="${baseClass}" style="color:${best.color}" title="${tip}">${best.display}</span>`;
            }
            return `<span class="no-match" title="No letter/number drill within ±0.08 mm">–</span>`;
        }

        return '';
    }

    /**
     * Format size cell in mm
     */
    function formatMmCell(sizeMm, sizeInch, useOversize) {
        let tip;
        if (useOversize) {
            const oversize = getDrillOversize(sizeInch);
            const expectedHole = sizeInch + oversize.mean;
            tip = `Drill: ${sizeMm.toFixed(3)} mm = ${sizeInch.toFixed(4)}"&#10;` +
                  `Expected oversize: +${(oversize.mean * 25.4).toFixed(3)} mm (+${(oversize.mean * 1000).toFixed(1)} thou)&#10;` +
                  `Expected hole: ~${(expectedHole * 25.4).toFixed(3)} mm`;
        } else {
            tip = `Hole: ${sizeMm.toFixed(3)} mm = ${sizeInch.toFixed(4)}"`;
        }
        return `<span class="drill-metric" title="${tip}">${sizeMm.toFixed(2)}</span>`;
    }

    /**
     * Format size cell in inches
     */
    function formatInchCell(sizeMm, sizeInch, useOversize) {
        let tip;
        if (useOversize) {
            const oversize = getDrillOversize(sizeInch);
            const expectedHole = sizeInch + oversize.mean;
            tip = `Drill: ${sizeMm.toFixed(3)} mm = ${sizeInch.toFixed(4)}"&#10;` +
                  `Expected oversize: +${(oversize.mean * 25.4).toFixed(3)} mm (+${(oversize.mean * 1000).toFixed(1)} thou)&#10;` +
                  `Expected hole: ~${(expectedHole * 25.4).toFixed(3)} mm`;
        } else {
            tip = `Hole: ${sizeMm.toFixed(3)} mm = ${sizeInch.toFixed(4)}"`;
        }
        return `<span class="drill-inch" title="${tip}">${sizeInch.toFixed(4)}</span>`;
    }

    // Track currently selected row
    let selectedRow = null;

    function selectRow(row) {
        // Deselect previous
        if (selectedRow) {
            selectedRow.classList.remove('selected');
        }
        // Select new
        selectedRow = row;
        if (row) {
            row.classList.add('selected');
        }
    }

    function updateTables(pct) {
        const threadPct = pct / 100;
        const useOversize = isOversizeEnabled();

        // Clear selection when tables update
        selectedRow = null;

        // Update UNC table
        const uncBody = document.querySelector('#unc-table tbody');
        uncBody.innerHTML = '';
        for (const [name, major, tpi] of UNC_THREADS) {
            const targetHoleInch = calcTapDrillInch(major, tpi, threadPct);
            const targetHoleMm = targetHoleInch * 25.4;

            // Get size to display (drill if oversize enabled, hole if not)
            const sizeInch = useOversize ? getDrillForTargetHole(targetHoleInch) : targetHoleInch;
            const sizeMm = sizeInch * 25.4;
            const drills = findDrillSizes(sizeMm, 0.08);

            const row = document.createElement('tr');
            row.dataset.type = 'inch';
            row.dataset.major = major;
            row.dataset.pitch = tpi;
            row.innerHTML = `
                <td class="thread-size">${name}-${tpi}</td>
                <td>${formatMmCell(sizeMm, sizeInch, useOversize)}</td>
                <td>${formatInchCell(sizeMm, sizeInch, useOversize)}</td>
                <td>${formatDrillCell(drills, 'frac')}</td>
                <td>${formatDrillCell(drills, 'letter')}</td>
            `;
            row.addEventListener('click', () => handleRowClick(row));
            uncBody.appendChild(row);
        }

        // Update UNF table
        const unfBody = document.querySelector('#unf-table tbody');
        unfBody.innerHTML = '';
        for (const [name, major, tpi] of UNF_THREADS) {
            const targetHoleInch = calcTapDrillInch(major, tpi, threadPct);
            const targetHoleMm = targetHoleInch * 25.4;

            const sizeInch = useOversize ? getDrillForTargetHole(targetHoleInch) : targetHoleInch;
            const sizeMm = sizeInch * 25.4;
            const drills = findDrillSizes(sizeMm, 0.08);

            const row = document.createElement('tr');
            row.dataset.type = 'inch';
            row.dataset.major = major;
            row.dataset.pitch = tpi;
            row.innerHTML = `
                <td class="thread-size">${name}-${tpi}</td>
                <td>${formatMmCell(sizeMm, sizeInch, useOversize)}</td>
                <td>${formatInchCell(sizeMm, sizeInch, useOversize)}</td>
                <td>${formatDrillCell(drills, 'frac')}</td>
                <td>${formatDrillCell(drills, 'letter')}</td>
            `;
            row.addEventListener('click', () => handleRowClick(row));
            unfBody.appendChild(row);
        }

        // Update Metric table
        const metricBody = document.querySelector('#metric-table tbody');
        metricBody.innerHTML = '';
        for (const [major, pitch] of METRIC_COARSE) {
            const targetHoleMm = calcTapDrillMm(major, pitch, threadPct);
            const targetHoleInch = targetHoleMm / 25.4;

            const sizeInch = useOversize ? getDrillForTargetHole(targetHoleInch) : targetHoleInch;
            const sizeMm = sizeInch * 25.4;
            const drills = findDrillSizes(sizeMm, 0.08);

            const row = document.createElement('tr');
            row.dataset.type = 'metric';
            row.dataset.major = major;
            row.dataset.pitch = pitch;
            row.innerHTML = `
                <td class="thread-size">M${major}×${pitch}</td>
                <td>${formatMmCell(sizeMm, sizeInch, useOversize)}</td>
                <td>${formatInchCell(sizeMm, sizeInch, useOversize)}</td>
                <td>${formatDrillCell(drills, 'frac')}</td>
                <td>${formatDrillCell(drills, 'letter')}</td>
            `;
            row.addEventListener('click', () => handleRowClick(row));
            metricBody.appendChild(row);
        }
    }

    /**
     * Handle click on a table row - populate custom calculator
     */
    function handleRowClick(row) {
        const type = row.dataset.type;
        const major = parseFloat(row.dataset.major);
        const pitch = parseFloat(row.dataset.pitch);

        // Select the row visually
        selectRow(row);

        // Set the radio button for metric/inch
        if (type === 'metric') {
            document.querySelector('input[name="custom-type"][value="metric"]').checked = true;
            // Update unit labels
            document.getElementById('major-unit').textContent = 'mm';
            document.getElementById('pitch-unit').textContent = 'mm';
        } else {
            document.querySelector('input[name="custom-type"][value="inch"]').checked = true;
            // Update unit labels
            document.getElementById('major-unit').textContent = 'in';
            document.getElementById('pitch-unit').textContent = 'TPI';
        }

        // Set the values
        customMajor.value = major;
        customPitch.value = pitch;

        // Update the result
        updateCustomResult();

        // Scroll control panel into view
        document.querySelector('.control-panel').scrollIntoView({
            behavior: 'smooth',
            block: 'nearest'
        });
    }

    // Forward declarations
    let updateCustomResult = function() {};

    /**
     * Update table column headers based on oversize toggle state
     */
    function updateColumnHeaders() {
        const useOversize = isOversizeEnabled();
        const mmHeaders = document.querySelectorAll('.col-mm');
        const inHeaders = document.querySelectorAll('.col-in');

        if (useOversize) {
            // When oversize is enabled: show drill recommendations
            mmHeaders.forEach(th => {
                th.textContent = 'Drill (mm)';
                th.title = 'Recommended drill size in mm (undersized to account for oversize)';
            });
            inHeaders.forEach(th => {
                th.textContent = 'Drill (in)';
                th.title = 'Recommended drill size in inches (undersized to account for oversize)';
            });
        } else {
            // When oversize is disabled: show hole diameter (drill = hole)
            mmHeaders.forEach(th => {
                th.textContent = 'Hole Ø (mm)';
                th.title = 'Target hole diameter for selected thread %';
            });
            inHeaders.forEach(th => {
                th.textContent = 'Hole Ø (in)';
                th.title = 'Target hole diameter for selected thread %';
            });
        }
    }

    function updateAll(pct) {
        updatePctDisplay(pct);
        updateColumnHeaders();
        updateTables(pct);
        updateCustomResult();
        updatePrintSummary(pct);
    }

    // Event listeners
    slider.addEventListener('input', (e) => {
        const pct = parseInt(e.target.value);
        updateAll(pct);
        updatePresetButtons(pct);
    });

    // Oversize toggle listener
    oversizeToggle.addEventListener('change', () => {
        updateAll(parseInt(slider.value));
    });

    // Formula toggle listener
    document.querySelectorAll('input[name="formula-type"]').forEach(radio => {
        radio.addEventListener('change', () => {
            updateAll(parseInt(slider.value));
        });
    });

    // Tap type toggle listener (cut vs roll)
    document.querySelectorAll('input[name="tap-type"]').forEach(radio => {
        radio.addEventListener('change', () => {
            const rollMode = isRollTap();
            // Show/hide formula option (not relevant for roll taps)
            const formulaRow = document.querySelector('input[name="formula-type"]').closest('.option-row');
            formulaRow.style.display = rollMode ? 'none' : 'flex';

            // If a material is selected, update thread % for new tap type
            if (selectedMaterial !== null) {
                const mat = MATERIALS[selectedMaterial];
                const pct = rollMode ? (mat.rollPct || mat.cutPct) : mat.cutPct;
                slider.value = pct;
                updateTapTypeIndicators(mat);
            }

            // Update everything
            updateAll(parseInt(slider.value));
        });
    });

    // ==========================================================================
    // MATERIAL PRESET SYSTEM
    // ==========================================================================

    let selectedMaterial = null;
    const materialBtnsContainer = document.getElementById('material-btns');
    const tapTypeLabels = document.querySelectorAll('input[name="tap-type"]');
    const cutLabel = tapTypeLabels[0].parentElement;
    const rollLabel = tapTypeLabels[1].parentElement;

    // Generate material buttons
    function initMaterialButtons() {
        materialBtnsContainer.innerHTML = '';
        MATERIALS.forEach((mat, idx) => {
            const btn = document.createElement('button');
            btn.className = 'preset-btn';
            btn.dataset.idx = idx;
            btn.textContent = mat.name;
            btn.title = mat.tip;
            if (mat.rollOk === 'no') {
                btn.title += '\n⚠ Roll tap: DO NOT USE';
            }
            btn.addEventListener('click', () => selectMaterial(idx));
            materialBtnsContainer.appendChild(btn);
        });
    }

    // Select a material and update UI
    function selectMaterial(idx) {
        selectedMaterial = idx;
        const mat = MATERIALS[idx];
        const roll = isRollTap();

        // Set thread % based on tap type
        const pct = roll ? (mat.rollPct || mat.cutPct) : mat.cutPct;
        slider.value = pct;

        // Update button active states
        materialBtnsContainer.querySelectorAll('.preset-btn').forEach((btn, i) => {
            btn.classList.toggle('active', i === idx);
        });

        // Update tap type indicators
        updateTapTypeIndicators(mat);

        // Update everything
        updateAll(pct);
    }

    // Update visual indicators on Cut/Roll radio labels
    function updateTapTypeIndicators(mat) {
        // Reset classes
        cutLabel.classList.remove('recommended', 'not-recommended');
        rollLabel.classList.remove('recommended', 'not-recommended', 'tap-type-warn');

        if (!mat) return;

        // Cut tap is always OK
        cutLabel.classList.add('recommended');

        // Roll tap depends on material
        if (mat.rollOk === 'yes') {
            rollLabel.classList.add('recommended');
        } else if (mat.rollOk === 'ok') {
            // Neutral - don't add any class
        } else {
            rollLabel.classList.add('not-recommended', 'tap-type-warn');
        }
    }

    // Update preset buttons to reflect current pct (for slider changes)
    function updatePresetButtons(pct) {
        // If slider moved away from a material's %, deselect it
        if (selectedMaterial !== null) {
            const mat = MATERIALS[selectedMaterial];
            const expectedPct = isRollTap() ? (mat.rollPct || mat.cutPct) : mat.cutPct;
            if (pct !== expectedPct) {
                selectedMaterial = null;
                materialBtnsContainer.querySelectorAll('.preset-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                updateTapTypeIndicators(null);
            }
        }
    }

    // Initialize material buttons
    initMaterialButtons();

    // ==========================================================================
    // CUSTOM THREAD CALCULATOR
    // ==========================================================================

    const customTypeRadios = document.querySelectorAll('input[name="custom-type"]');
    const customMajor = document.getElementById('custom-major');
    const customPitch = document.getElementById('custom-pitch');
    const customResult = document.getElementById('custom-result');
    const majorUnit = document.getElementById('major-unit');
    const pitchUnit = document.getElementById('pitch-unit');

    function getCustomType() {
        return document.querySelector('input[name="custom-type"]:checked').value;
    }

    updateCustomResult = function() {
        const major = parseFloat(customMajor.value);
        const pitch = parseFloat(customPitch.value);
        const pct = parseInt(slider.value) / 100;

        // Show placeholder if inputs are invalid/empty
        if (isNaN(major) || isNaN(pitch) || major <= 0 || pitch <= 0) {
            customResult.innerHTML = `<div class="result-row" style="color: var(--text-dim); justify-content: center;">Enter thread dimensions to see results</div>`;
            return;
        }

        let targetHoleMm, threadName;
        if (getCustomType() === 'metric') {
            targetHoleMm = calcTapDrillMm(major, pitch, pct);
            threadName = `M${major}×${pitch}`;
        } else {
            // Inch: major is in inches, pitch is TPI
            const targetHoleInch = calcTapDrillInch(major, pitch, pct);
            targetHoleMm = targetHoleInch * 25.4;
            threadName = `${major}"-${pitch} TPI`;
        }

        const targetHoleInch = targetHoleMm / 25.4;

        // Calculate drill size (with oversize adjustment)
        const drillInch = getDrillForTargetHole(targetHoleInch);
        const drillMm = drillInch * 25.4;
        const oversize = getDrillOversize(drillInch);

        // Find drill matches for both hole size and drill size
        const holeDrills = findDrillSizes(targetHoleMm, 0.08);
        const drillDrills = findDrillSizes(drillMm, 0.08);

        // Color based on compensation toggle: green = what tables show, dim = secondary info
        const useOversize = isOversizeEnabled();
        const holeColor = useOversize ? 'var(--text-dim)' : 'var(--success)';
        const drillColor = useOversize ? 'var(--success)' : 'var(--text-dim)';

        let html = `<div class="result-row"><span class="result-label">Thread:</span><strong>${threadName} @ ${slider.value}%</strong></div>`;

        // Section header: Hole (reamer/perfect)
        html += `<div class="result-row" style="border-top: 1px solid var(--accent); margin-top: 0.25rem; padding-top: 0.5rem;"><span class="result-label" style="color: ${holeColor}; font-weight: bold;">Hole Ø</span><span style="color: var(--text-dim); font-size: 0.8em;">(reamer / perfect)</span></div>`;
        html += `<div class="result-row"><span class="result-label">Size:</span><span>${targetHoleMm.toFixed(3)} mm / ${targetHoleInch.toFixed(4)}"</span></div>`;
        html += `<div class="result-row"><span class="result-label">Fractional:</span>${formatDrillCell(holeDrills, 'frac')}</div>`;
        html += `<div class="result-row"><span class="result-label">Letter/#:</span>${formatDrillCell(holeDrills, 'letter')}</div>`;

        // Section header: Drill (with oversize compensation)
        html += `<div class="result-row" style="border-top: 1px solid var(--accent); margin-top: 0.25rem; padding-top: 0.5rem;"><span class="result-label" style="color: ${drillColor}; font-weight: bold;">Drill</span><span style="color: var(--text-dim); font-size: 0.8em;">(compensated for oversize)</span></div>`;
        html += `<div class="result-row"><span class="result-label">Size:</span><span>${drillMm.toFixed(3)} mm / ${drillInch.toFixed(4)}"</span></div>`;
        html += `<div class="result-row"><span class="result-label">Fractional:</span>${formatDrillCell(drillDrills, 'frac')}</div>`;
        html += `<div class="result-row"><span class="result-label">Letter/#:</span>${formatDrillCell(drillDrills, 'letter')}</div>`;

        // Oversize info at the bottom
        html += `<div class="result-row" style="border-top: 1px solid var(--accent); margin-top: 0.25rem; padding-top: 0.5rem;"><span class="result-label">Exp. Oversize:</span><span>+${(oversize.mean * 25.4).toFixed(3)} mm / +${(oversize.mean * 1000).toFixed(1)} thou</span></div>`;

        customResult.innerHTML = html;
    };

    // Update unit labels when type changes
    customTypeRadios.forEach(radio => {
        radio.addEventListener('change', () => {
            if (getCustomType() === 'metric') {
                majorUnit.textContent = 'mm';
                pitchUnit.textContent = 'mm';
                customMajor.placeholder = '20';
                customPitch.placeholder = '1.5';
            } else {
                majorUnit.textContent = 'in';
                pitchUnit.textContent = 'TPI';
                customMajor.placeholder = '0.5';
                customPitch.placeholder = '13';
            }
            updateCustomResult();
        });
    });

    // Auto-calculate on input changes
    customMajor.addEventListener('input', updateCustomResult);
    customPitch.addEventListener('input', updateCustomResult);

    // Initial render (after all setup is complete)
    // Explicitly set slider value to override browser form restoration
    slider.value = 65;
    updateAll(65);
    </script>
</body>
</html>
